<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Agent Screen Share</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      color: #333;
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    .container {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      text-align: center;
      width: 100%;
      max-width: 400px;
    }
    h2 {
      margin-bottom: 20px;
      font-size: 1.8rem;
      color: #333;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 10px;
      transition: all 0.3s ease;
      box-shadow: 0 8px 20px rgba(40, 167, 69, 0.3);
      -webkit-tap-highlight-color: transparent;
    }
    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 25px rgba(40, 167, 69, 0.4);
    }
    button:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    p {
      margin-top: 15px;
      font-size: 14px;
      color: #555;
    }
    .session-box {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 8px;
    }
    .copy-btn {
      padding: 8px 16px;
      font-size: 12px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    video {
      width: 100%;
      max-height: 40vh;
      margin-top: 15px;
      border-radius: 8px;
      background: black;
      object-fit: contain;
    }
    .error-message {
      background: #f8d7da;
      color: #721c24;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      display: none;
      text-align: center;
      border-left: 4px solid #dc3545;
    }
    .status-bar {
      position: absolute;
      top: 15px;
      left: 15px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 10;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #28a745;
      animation: pulse 2s infinite;
    }
    .status-dot.connecting { background: #ffc107; }
    .status-dot.error { background: #dc3545; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .loading {
      text-align: center;
      padding: 20px;
      color: #666;
      display: none;
    }
    .loading-spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .device-info {
      font-size: 0.8rem;
      color: #666;
      text-align: center;
      margin-top: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 8px;
      display: none;
    }
    @media (max-width: 768px) {
      body { padding: 15px; }
      .container { padding: 20px; }
      h2 { font-size: 1.6rem; }
      video { max-height: 30vh; }
      .device-info { display: block; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ðŸ“º Agent Screen Share</h2>
    <p>Share your screen with viewers</p>
    <button id="startShare">Start Screen Share</button>
    <p>Session Code:</p>
    <div class="session-box">
      <span id="sessionCode">------</span>
      <button id="copyBtn" class="copy-btn">Copy</button>
    </div>
    <div class="error-message" id="errorMessage"></div>
    <div class="loading" id="loading">
      <div class="loading-spinner"></div>
      <p>Starting screen share...</p>
    </div>
    <div class="video-container" style="position: relative;">
      <div class="status-bar" id="statusBar">
        <div class="status-dot connecting" id="statusDot"></div>
        <span id="statusText">Ready</span>
      </div>
      <video id="preview" autoplay muted playsinline webkit-playsinline></video>
    </div>
    <div class="device-info" id="deviceInfo">
      Optimized for mobile sharing â€¢ Audio disabled
    </div>
  </div>

  <script type="module">
    import { db, auth } from "./firebase-config.js";
    import { ref, get, set, push, onValue, onChildAdded, off } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    const startBtn = document.getElementById("startShare");
    const sessionEl = document.getElementById("sessionCode");
    const preview = document.getElementById("preview");
    const copyBtn = document.getElementById("copyBtn");
    const errorMessage = document.getElementById("errorMessage");
    const loading = document.getElementById("loading");
    const statusBar = document.getElementById("statusBar");
    const statusDot = document.getElementById("statusDot");
    const statusText = document.getElementById("statusText");
    const deviceInfo = document.getElementById("deviceInfo");

    let hostPC = null;
    let localStream = null;
    let currentSessionCode = null;
    const maxReconnectAttempts = 3;
    let reconnectAttempts = 0;

    // Mobile detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Enhanced ICE configuration
    const pcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' },
        { urls: 'stun:stun.stunprotocol.org:3478' },
        { urls: 'stun:stun.cloudflare.com:3478' },
        { 
          urls: 'turn:openrelay.metered.ca:80', 
          username: 'openrelayproject', 
          credential: 'openrelayproject' 
        },
        { 
          urls: 'turn:openrelay.metered.ca:443', 
          username: 'openrelayproject', 
          credential: 'openrelayproject' 
        },
        { 
          urls: 'turn:openrelay.metered.ca:443?transport=tcp', 
          username: 'openrelayproject', 
          credential: 'openrelayproject' 
        },
        {
          urls: 'turn:turn.anyfirewall.com:443?transport=tcp',
          username: 'webrtc',
          credential: 'webrtc'
        },
        {
          urls: 'turn:relay1.expressturn.com:3478',
          username: 'efTAJF7M2TAqVIBR3T',
          credential: 'uxXXDrkXYdkVBdkl'
        }
      ],
      iceCandidatePoolSize: 10,
      iceTransportPolicy: 'all',
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    };

    // Authentication check
    onAuthStateChanged(auth, user => {
      if (!user) {
        window.location.href = "login.html";
      }
    });

    function showError(msg) {
      errorMessage.textContent = msg;
      errorMessage.style.display = 'block';
      setTimeout(() => {
        errorMessage.style.display = 'none';
      }, 10000);
    }

    function showLoading(show) {
      loading.style.display = show ? 'block' : 'none';
      startBtn.disabled = show;
      startBtn.textContent = show ? 'Starting...' : 'Start Screen Share';
    }

    function updateStatus(status, text) {
      statusDot.className = 'status-dot ' + status;
      statusText.textContent = text;
      console.log(`[Status] ${text}`);
    }

    function generateSessionCode() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    async function validateSessionCode(code) {
      const sessionRef = ref(db, `signaling/${code}`);
      const snapshot = await get(sessionRef);
      return !snapshot.exists();
    }

    async function startSharing() {
      showLoading(true);
      errorMessage.style.display = 'none';
      updateStatus('connecting', 'Starting screen share...');

      try {
        // Generate and validate unique session code
        let sessionCode = generateSessionCode();
        let isUnique = await validateSessionCode(sessionCode);
        let attempts = 0;
        while (!isUnique && attempts < 5) {
          sessionCode = generateSessionCode();
          isUnique = await validateSessionCode(sessionCode);
          attempts++;
        }
        if (!isUnique) {
          throw new Error("Unable to generate a unique session code. Please try again.");
        }

        currentSessionCode = sessionCode;
        sessionEl.innerText = sessionCode;

        // Get display media
        localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
        preview.srcObject = localStream;
        preview.muted = true;
        preview.playsInline = true;
        preview.setAttribute('playsinline', 'true');
        preview.setAttribute('webkit-playsinline', 'true');

        // Initialize WebRTC
        hostPC = new RTCPeerConnection(pcConfig);

        hostPC.onicecandidate = (event) => {
          if (event.candidate) {
            const hostCandidatesRef = ref(db, `signaling/${sessionCode}/hostCandidates`);
            push(hostCandidatesRef, event.candidate.toJSON());
            console.log(`[ICE] New host candidate: ${event.candidate.type} (${event.candidate.protocol})`);
          } else {
            console.log('[ICE] Host candidate gathering finished');
          }
        };

        hostPC.oniceconnectionstatechange = () => {
          const state = hostPC.iceConnectionState;
          console.log(`[ICE] Connection state: ${state}`);
          switch (state) {
            case 'checking':
              updateStatus('connecting', 'Checking connectivity...');
              break;
            case 'connected':
            case 'completed':
              updateStatus('connected', 'Connected to viewer');
              showLoading(false);
              reconnectAttempts = 0;
              break;
            case 'disconnected':
              updateStatus('connecting', 'Reconnecting...');
              if (reconnectAttempts < maxReconnectAttempts) {
                setTimeout(() => {
                  if (hostPC && hostPC.iceConnectionState === 'disconnected') {
                    console.log('[ICE] Attempting ICE restart...');
                    hostPC.restartIce();
                    reconnectAttempts++;
                  }
                }, 2000);
              }
              break;
            case 'failed':
              updateStatus('error', 'Connection failed');
              if (reconnectAttempts < maxReconnectAttempts) {
                showError(`Connection failed. Retrying... (${reconnectAttempts + 1}/${maxReconnectAttempts})`);
                setTimeout(() => attemptReconnect(), 3000);
              } else {
                showError('Connection failed after multiple attempts. Please restart sharing.');
                showLoading(false);
              }
              break;
            case 'closed':
              updateStatus('connecting', 'Connection closed');
              break;
          }
        };

        hostPC.onicegatheringstatechange = () => {
          console.log(`[ICE] Gathering state: ${hostPC.iceGatheringState}`);
        };

        hostPC.onconnectionstatechange = () => {
          console.log(`[Peer] Connection state: ${hostPC.connectionState}`);
        };

        // Add tracks
        localStream.getTracks().forEach(track => {
          hostPC.addTrack(track, localStream);
          console.log(`[Track] Added ${track.kind} track: ${track.label}`);
        });

        // Create and set offer
        const offer = await hostPC.createOffer();
        await hostPC.setLocalDescription(offer);
        await set(ref(db, `signaling/${sessionCode}/offer`), {
          sdp: offer.sdp,
          type: offer.type
        });

        // Listen for answer
        const answerRef = ref(db, `signaling/${sessionCode}/answer`);
        onValue(answerRef, async (snap) => {
          const val = snap.val();
          if (val && hostPC && !hostPC.remoteDescription) {
            try {
              await hostPC.setRemoteDescription(new RTCSessionDescription(val));
              console.log('[WebRTC] Remote description set (answer)');
            } catch (e) {
              console.error(`[WebRTC] Error setting remote description: ${e.message}`);
              showError('Failed to connect to viewer. Please try again.');
            }
          }
        });

        // Listen for viewer ICE candidates
        const viewerCandidatesRef = ref(db, `signaling/${sessionCode}/viewerCandidates`);
        onChildAdded(viewerCandidatesRef, async (snap) => {
          const val = snap.val();
          if (val && hostPC) {
            try {
              await hostPC.addIceCandidate(new RTCIceCandidate(val));
              console.log('[ICE] Viewer candidate added successfully');
            } catch (e) {
              console.error(`[ICE] Error adding viewer candidate: ${e.message}`);
            }
          }
        });

        // Handle track end
        localStream.getTracks().forEach(track => {
          track.onended = () => {
            console.log('[Track] Stream ended by user');
            disconnect();
          };
        });

        // Connection timeout
        setTimeout(() => {
          if (hostPC && hostPC.iceConnectionState !== 'connected' && hostPC.iceConnectionState !== 'completed') {
            console.log('[ICE] Connection timeout reached');
            showError('Connection timeout. Please try again.');
            showLoading(false);
          }
        }, 30000);

      } catch (error) {
        console.error(`[Error] ${error.message}`);
        showError(error.message || 'Failed to start screen sharing. Please try again.');
        showLoading(false);
        disconnect();
      }
    }

    async function attemptReconnect() {
      if (reconnectAttempts >= maxReconnectAttempts) return;

      reconnectAttempts++;
      console.log(`[Reconnect] Attempt ${reconnectAttempts}/${maxReconnectAttempts}`);

      disconnect();
      await new Promise(resolve => setTimeout(resolve, 1000));
      await startSharing();
    }

    function disconnect() {
      if (hostPC) {
        hostPC.close();
        hostPC = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      if (currentSessionCode) {
        off(ref(db, `signaling/${currentSessionCode}/answer`));
        off(ref(db, `signaling/${currentSessionCode}/viewerCandidates`));
        currentSessionCode = null;
      }
      preview.srcObject = null;
      sessionEl.innerText = '------';
      updateStatus('connecting', 'Ready');
      showLoading(false);
    }

    startBtn.onclick = startSharing;

    copyBtn.onclick = () => {
      const code = sessionEl.innerText;
      if (code !== '------') {
        navigator.clipboard.writeText(code);
        copyBtn.innerText = 'Copied!';
        setTimeout(() => copyBtn.innerText = 'Copy', 2000);
      }
    };

    // Mobile-specific video setup
    function setupVideoElement() {
      preview.muted = true;
      preview.playsInline = true;
      preview.setAttribute('playsinline', 'true');
      preview.setAttribute('webkit-playsinline', 'true');

      preview.addEventListener('loadedmetadata', () => {
        console.log(`[Video] Metadata loaded - ${preview.videoWidth}x${preview.videoHeight}`);
      });

      preview.addEventListener('playing', () => {
        console.log('[Video] Preview playing');
      });

      preview.addEventListener('error', (e) => {
        console.error('[Video] Error: ' + (e.target.error ? `${e.target.error.code} - ${e.target.error.message}` : 'Unknown error'));
        showError('Preview error. Please restart sharing.');
      });
    }

    // Handle page visibility changes
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && preview.srcObject && preview.paused) {
        console.log('[Video] Page became visible, ensuring preview plays');
        preview.play().catch(e => console.error('[Video] Visibility play failed: ' + e.message));
      }
    });

    // Handle mobile orientation changes
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (preview.srcObject && preview.paused) {
          console.log('[Video] Orientation changed, attempting to resume preview');
          preview.play().catch(e => console.error('[Video] Orientation play failed: ' + e.message));
        }
      }, 500);
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', disconnect);

    // Initialize
    setupVideoElement();
    console.log(`[Init] Agent initialized (Mobile: ${isMobile}, User Agent: ${navigator.userAgent.substring(0, 50)}...)`);

    // Display device info for debugging
    if (isMobile) {
      deviceInfo.innerHTML = `
        Mobile Device Detected<br>
        ${navigator.userAgent.includes('iPhone') ? 'iOS Safari' : 'Android Chrome'}<br>
        Audio: Disabled | Playsinline: Enabled
      `;
    }
  </script>

  <!--Start of Tawk.to Script-->
  <script type="text/javascript">
    var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
    (function(){
      var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
      s1.async=true;
      s1.src='https://embed.tawk.to/689782258b3b22192a593919/1j27t8oof';
      s1.charset='UTF-8';
      s1.setAttribute('crossorigin','*');
      s0.parentNode.insertBefore(s1,s0);
    })();
  </script>
  <!--End of Tawk.to Script-->
</body>
</html>
