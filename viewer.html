<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Screen Viewer</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { 
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif; 
      background:linear-gradient(135deg,#667eea 0%,#764ba2 100%); 
      min-height:100vh; 
      padding:20px; 
      color:#333; 
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    .container { 
      max-width:800px; 
      margin:0 auto; 
      background:rgba(255,255,255,0.95); 
      backdrop-filter:blur(10px); 
      border-radius:20px; 
      padding:30px; 
      box-shadow:0 20px 40px rgba(0,0,0,0.1); 
    }
    h2 { 
      text-align:center; 
      color:#333; 
      font-size:2rem; 
      margin-bottom:10px; 
      background:linear-gradient(135deg,#667eea,#764ba2); 
      -webkit-background-clip:text; 
      -webkit-text-fill-color:transparent; 
      background-clip:text; 
    }
    .subtitle { 
      text-align:center; 
      color:#666; 
      margin-bottom:30px; 
      font-size:1.1rem; 
    }
    .input-container { 
      display:flex; 
      flex-direction:column; 
      gap:15px; 
      margin-bottom:30px; 
      align-items:center; 
    }
    #sessionInput { 
      width:100%; 
      max-width:300px; 
      padding:15px 20px; 
      font-size:1.2rem; 
      font-weight:bold; 
      text-align:center; 
      letter-spacing:2px; 
      border:3px solid #e1e5e9; 
      border-radius:12px; 
      background:white; 
      transition:all 0.3s ease; 
      text-transform:uppercase; 
      outline:none;
      -webkit-user-select: text;
      user-select: text;
    }
    #sessionInput:focus { 
      border-color:#667eea; 
      box-shadow:0 0 0 4px rgba(102,126,234,0.2); 
    }
    #joinBtn { 
      width:100%; 
      max-width:300px; 
      padding:15px 25px; 
      background:linear-gradient(135deg,#28a745,#20c997); 
      color:white; 
      border:none; 
      border-radius:12px; 
      font-size:1.1rem; 
      font-weight:600; 
      cursor:pointer; 
      transition:all 0.3s ease; 
      box-shadow:0 8px 20px rgba(40,167,69,0.3); 
      -webkit-tap-highlight-color:transparent; 
      touch-action: manipulation;
    }
    #joinBtn:hover:not(:disabled) { 
      transform:translateY(-2px); 
      box-shadow:0 12px 25px rgba(40,167,69,0.4); 
    }
    #joinBtn:disabled { 
      background:#6c757d; 
      cursor:not-allowed; 
      transform:none; 
      box-shadow:none; 
    }
    .video-container { 
      margin-top:20px; 
      border-radius:15px; 
      overflow:hidden; 
      background:#000; 
      position:relative; 
      box-shadow:0 10px 30px rgba(0,0,0,0.3); 
      display:none; 
    }
    .video-container.active { 
      display:block; 
    }
    #remoteVideo { 
      width:100%; 
      height:auto; 
      min-height:200px; 
      max-height:70vh; 
      object-fit:contain; 
      background:#000; 
      display:block;
    }
    .status-bar { 
      position:absolute; 
      top:15px; 
      left:15px; 
      background:rgba(0,0,0,0.8); 
      color:white; 
      padding:8px 12px; 
      border-radius:20px; 
      font-size:0.9rem; 
      font-weight:500; 
      display:flex; 
      align-items:center; 
      gap:8px; 
      z-index:10; 
    }
    .status-dot { 
      width:8px; 
      height:8px; 
      border-radius:50%; 
      background:#28a745; 
      animation:pulse 2s infinite; 
    }
    .status-dot.connecting { background:#ffc107; }
    .status-dot.error { background:#dc3545; }
    @keyframes pulse { 0%,100% {opacity:1;} 50% {opacity:0.5;} }
    .controls { 
      display:flex; 
      justify-content:center; 
      gap:15px; 
      margin-top:20px; 
      flex-wrap:wrap; 
    }
    .disconnect-btn { 
      padding:10px 20px; 
      background:linear-gradient(135deg,#dc3545,#c82333); 
      color:white; 
      border:none; 
      border-radius:8px; 
      font-weight:600; 
      cursor:pointer; 
      transition:all 0.3s ease; 
      -webkit-tap-highlight-color:transparent; 
      touch-action: manipulation;
    }
    .error-message { 
      background:#f8d7da; 
      color:#721c24; 
      padding:15px; 
      border-radius:8px; 
      margin:15px 0; 
      display:none; 
      text-align:center; 
      border-left:4px solid #dc3545; 
    }
    .ice-status { 
      background:#e9ecef; 
      padding:10px; 
      border-radius:8px; 
      margin:10px 0; 
      font-family:monospace; 
      font-size:0.8rem; 
      display:none; 
      max-height:150px; 
      overflow-y:auto; 
    }
    .loading { 
      text-align:center; 
      padding:20px; 
      color:#666; 
      display:none; 
    }
    .loading-spinner { 
      border:3px solid #f3f3f3; 
      border-top:3px solid #667eea; 
      border-radius:50%; 
      width:40px; 
      height:40px; 
      animation:spin 1s linear infinite; 
      margin:0 auto 10px; 
    }
    @keyframes spin { 0% { transform:rotate(0deg); } 100% { transform:rotate(360deg); } }
    .device-info {
      font-size: 0.8rem;
      color: #666;
      text-align: center;
      margin-top: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.7);
      border-radius: 8px;
      display: none;
    }
    .play-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px 30px;
      border-radius: 12px;
      font-size: 1.2rem;
      font-weight: 600;
      text-align: center;
      z-index: 20;
      display: none;
      max-width: 90%;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    .play-prompt.visible {
      display: block;
    }
    @media (max-width:768px) { 
      body { padding:15px; } 
      .container { padding:20px; } 
      h2 { font-size:1.6rem; } 
      #remoteVideo { max-height:60vh; }
      .device-info { display: block; }
      .play-prompt { font-size: 1rem; padding: 15px 25px; }
    }
  </style>
</head>
<body>
<div class="container">
  <h2>ðŸ“± Screen Viewer</h2>
  <p class="subtitle">Mobile & Desktop Friendly<br>iOS: Use Safari | Android: Use Chrome</p>
  
  <div class="input-container">
    <input type="text" id="sessionInput" placeholder="ABCDEF" maxlength="6" autocomplete="off" inputmode="text">
    <button id="joinBtn">ðŸ”— Connect</button>
  </div>

  <div class="device-info" id="deviceInfo">
    Optimized for mobile viewing â€¢ Audio automatically muted
  </div>

  <div class="error-message" id="errorMessage"></div>
  <div class="ice-status" id="iceStatus"></div>

  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <p>Connecting via TURN servers...</p>
  </div>

  <div class="video-container" id="videoContainer">
    <div class="status-bar" id="statusBar">
      <div class="status-dot connecting" id="statusDot"></div>
      <span id="statusText">Connecting...</span>
    </div>
    <div class="play-prompt" id="playPrompt">Tap to start video playback</div>
    <video id="remoteVideo" playsinline muted webkit-playsinline controls></video>
  </div>

  <div class="controls" id="controls" style="display:none;">
    <button class="disconnect-btn" id="disconnectBtn">Disconnect</button>
    <button class="disconnect-btn" id="toggleIceBtn" style="background:#6c757d;">Show ICE</button>
    <button class="disconnect-btn" id="fullscreenBtn" style="background:#007bff;">Fullscreen</button>
  </div>
</div>

<script type="module">
import { db } from "./firebase-config.js";
import { ref, get, set, push, onChildAdded, off } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

const joinBtn = document.getElementById("joinBtn");
const sessionInput = document.getElementById("sessionInput");
const remoteVideo = document.getElementById("remoteVideo");
const errorMessage = document.getElementById("errorMessage");
const loading = document.getElementById("loading");
const videoContainer = document.getElementById("videoContainer");
const controls = document.getElementById("controls");
const statusBar = document.getElementById("statusBar");
const statusDot = document.getElementById("statusDot");
const statusText = document.getElementById("statusText");
const disconnectBtn = document.getElementById("disconnectBtn");
const toggleIceBtn = document.getElementById("toggleIceBtn");
const fullscreenBtn = document.getElementById("fullscreenBtn");
const iceStatus = document.getElementById("iceStatus");
const deviceInfo = document.getElementById("deviceInfo");
const playPrompt = document.getElementById("playPrompt");

let currentPC = null;
let currentSessionCode = null;
let iceDebug = false;
let reconnectAttempts = 0;
const maxReconnectAttempts = 3;
let isUserInteracted = false;
let playAttemptCount = 0;
const maxPlayAttempts = 5;

// Enhanced ICE configuration with more TURN servers for mobile reliability
const pcConfig = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    { urls: 'stun:stun3.l.google.com:19302' },
    { urls: 'stun:stun4.l.google.com:19302' },
    { urls: 'stun:stun.stunprotocol.org:3478' },
    { urls: 'stun:stun.cloudflare.com:3478' },
    { 
      urls: 'turn:openrelay.metered.ca:80', 
      username: 'openrelayproject', 
      credential: 'openrelayproject' 
    },
    { 
      urls: 'turn:openrelay.metered.ca:443', 
      username: 'openrelayproject', 
      credential: 'openrelayproject' 
    },
    { 
      urls: 'turn:openrelay.metered.ca:443?transport=tcp', 
      username: 'openrelayproject', 
      credential: 'openrelayproject' 
    },
    {
      urls: 'turn:turn.anyfirewall.com:443?transport=tcp',
      username: 'webrtc',
      credential: 'webrtc'
    },
    {
      urls: 'turn:relay1.expressturn.com:3478',
      username: 'efTAJF7M2TAqVIBR3T',
      credential: 'uxXXDrkXYdkVBdkl'
    }
  ],
  iceCandidatePoolSize: 10,
  iceTransportPolicy: 'all',
  bundlePolicy: 'max-bundle',
  rtcpMuxPolicy: 'require',
  sdpSemantics: 'unified-plan'
};

// Mobile detection
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
const isNonSafariIOS = isIOS && !navigator.userAgent.includes('Safari');

function logIce(msg) { 
  console.log(`[ICE] ${msg}`); 
  if (iceDebug) { 
    const time = new Date().toLocaleTimeString(); 
    iceStatus.innerHTML += `[${time}] ${msg}<br>`; 
    iceStatus.scrollTop = iceStatus.scrollHeight; 
  } 
}

function showError(msg) {
  errorMessage.textContent = msg; 
  errorMessage.style.display = 'block'; 
  setTimeout(() => { 
    errorMessage.style.display = 'none'; 
  }, 20000);
  logIce(`UI Error: ${msg}`);
}

function showLoading(show) { 
  loading.style.display = show ? 'block' : 'none'; 
  joinBtn.disabled = show; 
  joinBtn.textContent = show ? 'Connecting...' : 'ðŸ”— Connect'; 
}

function updateStatus(status, text) { 
  statusDot.className = 'status-dot ' + status; 
  statusText.textContent = text; 
  logIce(`Status: ${text}`); 
}

function showVideoContainer() { 
  videoContainer.classList.add('active'); 
  controls.style.display = 'flex'; 
}

function hideVideoContainer() { 
  videoContainer.classList.remove('active'); 
  controls.style.display = 'none'; 
  playPrompt.classList.remove('visible');
}

function setupVideoElement() {
  remoteVideo.muted = true;
  remoteVideo.playsInline = true;
  remoteVideo.autoplay = false;
  remoteVideo.setAttribute('playsinline', 'true');
  remoteVideo.setAttribute('webkit-playsinline', 'true');
  remoteVideo.setAttribute('muted', 'true');
  remoteVideo.defaultMuted = true;
  remoteVideo.volume = 0;

  if (isMobile) {
    remoteVideo.controls = true;
    logIce('Mobile: Video controls enabled for user interaction');
  }

  remoteVideo.addEventListener('loadstart', () => {
    logIce('Video: Load started');
  });

  remoteVideo.addEventListener('loadeddata', () => {
    logIce('Video: Data loaded');
  });

  remoteVideo.addEventListener('loadedmetadata', () => {
    logIce(`Video: Metadata loaded - ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`);
    attemptVideoPlay('metadata loaded', 200);
  });

  remoteVideo.addEventListener('canplay', () => { 
    logIce('Video: Can play'); 
    attemptVideoPlay('canplay event', 100);
  });

  remoteVideo.addEventListener('playing', () => {
    logIce('Video: Playing started');
    updateStatus('connected', 'Video playing');
    playPrompt.classList.remove('visible');
    playAttemptCount = 0;
    if (isMobile && !isIOS) {
      setTimeout(() => remoteVideo.controls = false, 3000);
    }
  });

  remoteVideo.addEventListener('pause', () => {
    logIce('Video: Paused');
    if (remoteVideo.srcObject && isMobile) {
      playPrompt.classList.add('visible');
    }
  });

  remoteVideo.addEventListener('waiting', () => {
    logIce('Video: Waiting for data');
    if (isMobile) {
      playPrompt.classList.add('visible');
    }
  });

  remoteVideo.addEventListener('error', (e) => {
    const error = e.target.error;
    logIce('Video error: ' + (error ? `${error.code} - ${error.message}` : 'Unknown error'));
    showError('Video playback error. Tap the video to retry or reconnect.');
    if (isMobile) {
      playPrompt.classList.add('visible');
    }
  });

  remoteVideo.addEventListener('stalled', () => {
    logIce('Video: Stalled, attempting to recover');
    if (isMobile) {
      playPrompt.classList.add('visible');
    }
  });

  remoteVideo.addEventListener('click', () => {
    attemptVideoPlay('user click', 0);
  });

  remoteVideo.addEventListener('touchstart', (e) => {
    e.preventDefault();
    attemptVideoPlay('user touch', 0);
  });
}

function attemptVideoPlay(reason, delay = 0) {
  if (!remoteVideo.srcObject) {
    logIce(`Play attempt skipped - no source (${reason})`);
    return;
  }

  if (playAttemptCount >= maxPlayAttempts) {
    logIce(`Max play attempts (${maxPlayAttempts}) reached for ${reason}`);
    showError('Unable to start video. Please reconnect or switch to a supported browser.');
    return;
  }

  setTimeout(() => {
    logIce(`Attempting video play (${playAttemptCount + 1}/${maxPlayAttempts}): ${reason}`);
    const playPromise = remoteVideo.play();

    if (playPromise !== undefined) {
      playPromise.then(() => {
        logIce(`Video play successful: ${reason}`);
        playPrompt.classList.remove('visible');
        isUserInteracted = true;
        playAttemptCount = 0;
      }).catch(e => {
        logIce(`Video play failed (${reason}): ${e.message}`);
        playAttemptCount++;
        if (e.name === 'NotAllowedError') {
          showError('Tap the video to start playback (browser security requirement)');
          if (isMobile) {
            playPrompt.classList.add('visible');
          }
          if (playAttemptCount < maxPlayAttempts) {
            attemptVideoPlay(`retry after ${reason}`, 1000 * Math.min(playAttemptCount, 3));
          }
        } else if (e.name === 'AbortError') {
          logIce('Play aborted, likely due to new play request');
        } else {
          showError(`Video playback issue (${e.name}): Tap the video or reconnect.`);
          if (isMobile) {
            playPrompt.classList.add('visible');
          }
        }
      });
    }
  }, delay);
}

async function fetchOfferWithRetry(code, retries = 3, delay = 1000) {
  for (let i = 0; i < retries; i++) {
    try {
      const offerSnap = await get(ref(db, `signaling/${code}/offer`));
      if (!offerSnap.exists()) {
        throw new Error("Session not found. Please check the code or ensure the agent is active.");
      }
      return offerSnap.val();
    } catch (error) {
      logIce(`Offer fetch attempt ${i + 1}/${retries} failed: ${error.message}`);
      if (i < retries - 1) {
        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
      } else {
        throw error;
      }
    }
  }
}

async function joinSession() {
  const code = sessionInput.value.trim().toUpperCase();
  if (!code || code.length !== 6) { 
    showError("Please enter a valid 6-digit session code"); 
    return;
  }

  if (isNonSafariIOS) {
    showError("iOS: Please open this page in Safari for video support.");
    return;
  }
  
  showLoading(true); 
  errorMessage.style.display = 'none'; 
  logIce(`Starting connection to session: ${code} (Mobile: ${isMobile}, iOS: ${isIOS}, Browser: ${navigator.userAgent.substring(0, 50)}...)`);
  
  try {
    currentPC = new RTCPeerConnection(pcConfig); 
    currentSessionCode = code;
    reconnectAttempts = 0;
    playAttemptCount = 0;

    currentPC.oniceconnectionstatechange = () => {
      const state = currentPC.iceConnectionState;
      logIce(`ICE connection state: ${state}`);
      switch (state) {
        case 'checking':
          updateStatus('connecting', 'Checking connectivity...');
          break;
        case 'connected':
        case 'completed':
          updateStatus('connected', 'Connected via ICE');
          showLoading(false);
          reconnectAttempts = 0;
          logIce(`Connection summary: ICE=${state}, Peer=${currentPC.connectionState}`);
          break;
        case 'disconnected':
          updateStatus('connecting', 'Reconnecting...');
          if (reconnectAttempts < maxReconnectAttempts) {
            setTimeout(() => {
              if (currentPC && currentPC.iceConnectionState === 'disconnected') {
                logIce('Attempting ICE restart...');
                currentPC.restartIce();
                reconnectAttempts++;
              }
            }, 2000);
          }
          break;
        case 'failed':
          updateStatus('error', 'Connection failed');
          if (reconnectAttempts < maxReconnectAttempts) {
            showError(`Connection failed. Retrying... (${reconnectAttempts + 1}/${maxReconnectAttempts})`);
            setTimeout(() => attemptReconnect(), 3000);
          } else {
            showError('Connection failed after multiple attempts. Check network or agent status.');
            showLoading(false);
          }
          break;
        case 'closed':
          updateStatus('connecting', 'Connection closed');
          break;
      }
    };

    currentPC.onicegatheringstatechange = () => { 
      logIce(`ICE gathering state: ${currentPC.iceGatheringState}`); 
    };

    currentPC.onicecandidate = async (event) => { 
      if (event.candidate) { 
        const candidateType = event.candidate.candidate.includes('typ host') ? 'host' : 
                             event.candidate.candidate.includes('typ srflx') ? 'srflx' : 
                             event.candidate.candidate.includes('typ relay') ? 'relay' : 'unknown';
        logIce(`New ICE candidate: ${candidateType} (${event.candidate.protocol})`);
        const viewerCandidatesRef = ref(db, `signaling/${code}/viewerCandidates`);
        await push(viewerCandidatesRef, event.candidate.toJSON());
      } else { 
        logIce('ICE candidate gathering finished'); 
      } 
    };

    currentPC.onconnectionstatechange = () => { 
      const state = currentPC.connectionState; 
      logIce(`Peer connection state: ${state}`); 
    };

    currentPC.ontrack = (event) => {
      logIce('=== TRACK EVENT RECEIVED ===');
      logIce(`Event streams: ${event.streams.length}`);
      logIce(`Event track: ${event.track.kind} - ${event.track.readyState}`);
      
      const stream = event.streams[0];
      
      if (stream) {
        const videoTracks = stream.getVideoTracks();
        const audioTracks = stream.getAudioTracks();
        
        logIce(`Stream ID: ${stream.id}`);
        logIce(`Video tracks: ${videoTracks.length}`);
        logIce(`Audio tracks: ${audioTracks.length}`);
        
        if (videoTracks.length > 0) {
          const videoTrack = videoTracks[0];
          logIce(`Video track: ${videoTrack.label} - ${videoTrack.readyState} - Enabled: ${videoTrack.enabled}`);
        } else {
          logIce('ERROR: No video tracks received');
          showError('No video stream from agent. Ensure agent is sharing screen.');
          return;
        }
        
        remoteVideo.srcObject = stream;
        showVideoContainer();
        updateStatus('connected', 'Stream received');
        
        setTimeout(() => {
          logIce(`Video element: ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`);
          logIce(`Video paused: ${remoteVideo.paused}`);
          logIce(`Video muted: ${remoteVideo.muted}`);
          logIce(`Video readyState: ${remoteVideo.readyState}`);
          attemptVideoPlay('track received', 500);
        }, 500);
        
        showLoading(false);
      } else {
        logIce('ERROR: No stream received in track event');
        showError('Failed to receive stream from agent. Please reconnect.');
      }
    };

    const offer = await fetchOfferWithRetry(code);
    await currentPC.setRemoteDescription(new RTCSessionDescription(offer));

    const answerConstraints = {
      offerToReceiveVideo: true,
      offerToReceiveAudio: false
    };

    const answer = await currentPC.createAnswer(answerConstraints);
    await currentPC.setLocalDescription(answer);
    await set(ref(db, `signaling/${code}/answer`), {
      sdp: answer.sdp,
      type: answer.type
    });

    onChildAdded(ref(db, `signaling/${code}/hostCandidates`), async (snap) => {
      if (currentPC && snap.val()) { 
        try { 
          const candidate = snap.val();
          const candidateType = candidate.candidate.includes('typ host') ? 'host' : 
                               candidate.candidate.includes('typ srflx') ? 'srflx' : 
                               candidate.candidate.includes('typ relay') ? 'relay' : 'unknown';
          logIce(`Received ICE candidate: ${candidateType}`);
          await currentPC.addIceCandidate(new RTCIceCandidate(candidate)); 
          logIce('ICE candidate added successfully');
        } catch (e) { 
          logIce(`Error adding ICE candidate: ${e.message}`); 
          showError(`ICE candidate error: ${e.message}. Check network or agent.`);
        } 
      }
    });

    setTimeout(() => {
      if (currentPC && currentPC.iceConnectionState !== 'connected' && currentPC.iceConnectionState !== 'completed') {
        logIce('Connection timeout reached');
        showError('Connection timeout. Check network or ensure agent is active.');
        showLoading(false);
      }
    }, 30000);

  } catch (error) { 
    logIce(`Connection error: ${error.message}`);
    let errorMsg = error.message || 'Connection failed. Please try again.';
    if (error.message.includes('permission denied')) {
      errorMsg = 'Firebase access denied. Check session code or contact support.';
    } else if (error.message.includes('Session not found')) {
      errorMsg += ' Ensure the agent is running on desktop.';
    }
    showError(errorMsg); 
    showLoading(false);
  }
}

async function attemptReconnect() {
  if (reconnectAttempts >= maxReconnectAttempts) return;
  
  reconnectAttempts++;
  logIce(`Reconnect attempt ${reconnectAttempts}/${maxReconnectAttempts}`);
  
  if (currentPC) {
    currentPC.close();
    currentPC = null;
  }
  
  await new Promise(resolve => setTimeout(resolve, 1000 * reconnectAttempts));
  await joinSession();
}

function disconnect() { 
  if (currentPC) { 
    currentPC.close(); 
    currentPC = null; 
  } 
  if (currentSessionCode) { 
    off(ref(db, `signaling/${currentSessionCode}/hostCandidates`)); 
    currentSessionCode = null; 
  } 
  remoteVideo.srcObject = null; 
  hideVideoContainer(); 
  showLoading(false); 
  sessionInput.value = ''; 
  updateStatus('connecting', 'Disconnected');
  reconnectAttempts = 0;
  playAttemptCount = 0;
  isUserInteracted = false;
}

function toggleIceDebug() { 
  iceDebug = !iceDebug; 
  iceStatus.style.display = iceDebug ? 'block' : 'none'; 
  toggleIceBtn.textContent = iceDebug ? 'Hide ICE' : 'Show ICE'; 
  if (iceDebug) { 
    iceStatus.innerHTML = '=== ICE Debug Started ===<br>'; 
  } 
}

function toggleFullscreen() {
  if (!document.fullscreenElement) {
    if (remoteVideo.requestFullscreen) {
      remoteVideo.requestFullscreen();
    } else if (remoteVideo.webkitRequestFullscreen) {
      remoteVideo.webkitRequestFullscreen();
    } else if (remoteVideo.msRequestFullscreen) {
      remoteVideo.msRequestFullscreen();
    }
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
  }
}

sessionInput.addEventListener('input', function() { 
  this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, ''); 
});

sessionInput.addEventListener('keypress', (e) => { 
  if (e.key === 'Enter') { 
    joinSession(); 
  } 
});

joinBtn.onclick = joinSession;
disconnectBtn.onclick = disconnect;
toggleIceBtn.onclick = toggleIceDebug;
fullscreenBtn.onclick = toggleFullscreen;

setupVideoElement();

document.addEventListener('visibilitychange', () => {
  if (!document.hidden && currentPC && remoteVideo.srcObject) {
    logIce('Page became visible, ensuring video plays');
    attemptVideoPlay('visibility change', 500);
  }
});

window.addEventListener('orientationchange', () => {
  setTimeout(() => {
    if (remoteVideo.srcObject) {
      logIce('Orientation changed, attempting to resume');
      attemptVideoPlay('orientation change', 500);
    }
  }, 500);
});

window.addEventListener('beforeunload', disconnect);

let userInteracted = false;
function handleUserInteraction() {
  if (!userInteracted) {
    userInteracted = true;
    isUserInteracted = true;
    logIce('User interaction detected');
    if (remoteVideo.srcObject && remoteVideo.paused) {
      attemptVideoPlay('user interaction', 0);
    }
  }
}

document.addEventListener('touchstart', handleUserInteraction);
document.addEventListener('click', handleUserInteraction);

if (isIOS) {
  logIce('iOS device detected, applying iOS-specific workarounds');
  remoteVideo.controls = true;
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && remoteVideo.srcObject) {
      logIce('iOS: App became visible, checking video state');
      setTimeout(() => {
        if (remoteVideo.paused) {
          logIce('iOS: Video paused, attempting to resume');
          attemptVideoPlay('iOS visibility', 500);
        }
      }, 500);
    }
  });
  window.addEventListener('pageshow', () => {
    if (remoteVideo.srcObject && remoteVideo.paused) {
      logIce('iOS: Page shown, attempting video play');
      attemptVideoPlay('iOS pageshow', 500);
    }
  });
}

logIce(`Viewer initialized (Mobile: ${isMobile}, iOS: ${isIOS}, Browser: ${navigator.userAgent.substring(0, 50)}...)`);

if (isMobile) {
  deviceInfo.innerHTML = `
    Mobile Device Detected<br>
    ${isIOS ? 'iOS: Use Safari for video support' : 'Android: Use Chrome for best experience'}<br>
    Audio: Muted | Playsinline: Enabled
  `;
}
</script>
<!--Start of Tawk.to Script-->
<script type="text/javascript">
var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
s1.async=true;
s1.src='https://embed.tawk.to/689782258b3b22192a593919/1j27t8oof';
s1.charset='UTF-8';
s1.setAttribute('crossorigin','*');
s0.parentNode.insertBefore(s1,s0);
})();
</script>
<!--End of Tawk.to Script-->
</body>
</html>
