<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Screen Viewer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    :root {
      --primary-color: #007bff;
      --secondary-color: #6c757d;
      --accent-color: #28a745;
      --bg-start: #667eea;
      --bg-end: #764ba2;
      --card-bg: rgba(255, 255, 255, 0.95);
      --text-color: #333;
      --error-color: #dc3545;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      --border-radius: 12px;
      --transition-speed: 0.3s;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;
      background: linear-gradient(135deg, var(--bg-start) 0%, var(--bg-end) 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      color: var(--text-color);
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      font-size: 16px;
    }
    .container {
      max-width: 800px;
      width: 100%;
      background: var(--card-bg);
      backdrop-filter: blur(10px);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      padding: 30px;
      text-align: center;
      position: relative;
      animation: fadeIn 0.8s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    h1 {
      font-size: 28px;
      color: var(--text-color);
      margin-bottom: 20px;
      font-weight: 600;
    }
    .input-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin-bottom: 25px;
    }
    #sessionInput {
      width: 100%;
      max-width: 200px;
      padding: 12px 10px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 20px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 2px;
      outline: none;
      transition: border-color var(--transition-speed);
    }
    #sessionInput:focus {
      border-color: var(--primary-color);
    }
    #joinBtn {
      width: 100%;
      max-width: 200px;
      padding: 12px;
      border: none;
      background-color: var(--primary-color);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }
    #joinBtn:hover {
      background-color: #0056b3;
      transform: translateY(-2px);
    }
    #joinBtn:disabled {
      background-color: #aaa;
      cursor: not-allowed;
      transform: none;
    }
    #errorMessage {
      color: var(--error-color);
      margin-top: -15px;
      margin-bottom: 15px;
      font-weight: bold;
      display: none;
      animation: fadeIn 0.5s ease-in-out;
    }
    .video-container {
      position: relative;
      width: 100%;
      padding-top: 56.25%; /* 16:9 Aspect Ratio */
      background: #000;
      border-radius: var(--border-radius);
      overflow: hidden;
      margin-top: 20px;
      display: none;
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    .video-container.active {
      display: block;
    }
    #remoteVideo {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      z-index: 10;
      display: none;
    }
    .status-bar {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      font-size: 16px;
      font-weight: 500;
      color: #666;
    }
    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: pulse 1.5s infinite ease-in-out;
    }
    .status-dot.connecting { background-color: orange; }
    .status-dot.connected { background-color: var(--accent-color); animation: none; }
    .status-dot.error { background-color: var(--error-color); animation: none; }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }
    .controls {
      display: none;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 20px;
    }
    .control-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px 15px;
      border: none;
      border-radius: 8px;
      background-color: var(--secondary-color);
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }
    .control-btn:hover {
      background-color: #5a6268;
      transform: translateY(-2px);
    }
    .control-btn i {
      margin-right: 8px;
    }
    .debug-status {
      text-align: left;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-all;
      background: #f0f0f0;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }
    .device-info {
      font-size: 13px;
      color: #777;
      margin-top: 15px;
      line-height: 1.4;
    }
    #playPrompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 20px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 18px;
      text-align: center;
      z-index: 20;
      display: none;
      transition: opacity 0.5s;
    }
    #playPrompt.visible {
      display: block;
      opacity: 1;
    }
    @media (max-width: 600px) {
      .container { padding: 20px; }
      h1 { font-size: 24px; }
      .input-group { flex-direction: column; }
      #sessionInput, #joinBtn { max-width: 100%; }
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>Connect to Screen Share</h1>
    <div class="input-group">
      <input type="text" id="sessionInput" placeholder="Enter Code" maxlength="6">
      <button id="joinBtn">Connect</button>
    </div>
    <div id="errorMessage"></div>
    <div class="device-info" id="deviceInfo"></div>

    <div class="video-container" id="videoContainer">
      <video id="remoteVideo" autoplay playsinline></video>
      <div id="loading">Connecting...</div>
      <div id="playPrompt">Tap to Play</div>
    </div>

    <div class="status-bar" id="statusBar">
      <div id="statusDot" class="status-dot connecting"></div>
      <div id="statusText">Enter code to connect</div>
    </div>

    <div class="controls" id="controls">
      <button id="disconnectBtn" class="control-btn"><i class="fas fa-times"></i> Disconnect</button>
      <button id="fullscreenBtn" class="control-btn"><i class="fas fa-expand"></i> Fullscreen</button>
      <button id="toggleIceBtn" class="control-btn"><i class="fas fa-code"></i> Show ICE</button>
    </div>

    <div class="debug-status" id="iceStatus"></div>
  </div>

  <script type="module">
    import { db } from "./firebase-config.js";
    import { ref, get, set, push, onChildAdded, off } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    const joinBtn = document.getElementById("joinBtn");
    const sessionInput = document.getElementById("sessionInput");
    const remoteVideo = document.getElementById("remoteVideo");
    const errorMessage = document.getElementById("errorMessage");
    const loading = document.getElementById("loading");
    const videoContainer = document.getElementById("videoContainer");
    const controls = document.getElementById("controls");
    const statusBar = document.getElementById("statusBar");
    const statusDot = document.getElementById("statusDot");
    const statusText = document.getElementById("statusText");
    const disconnectBtn = document.getElementById("disconnectBtn");
    const toggleIceBtn = document.getElementById("toggleIceBtn");
    const fullscreenBtn = document.getElementById("fullscreenBtn");
    const iceStatus = document.getElementById("iceStatus");
    const deviceInfo = document.getElementById("deviceInfo");
    const playPrompt = document.getElementById("playPrompt");

    let currentPC = null;
    let currentSessionCode = null;
    let iceDebug = false;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 3;
    let isUserInteracted = false;
    let playAttemptCount = 0;
    const maxPlayAttempts = 5;

    // Enhanced ICE configuration with more TURN servers for mobile reliability
    const pcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' },
        { urls: 'stun:stun.stunprotocol.org:3478' },
        { urls: 'stun:stun.cloudflare.com:3478' },
        {
          urls: 'turn:openrelay.metered.ca:80',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:openrelay.metered.ca:443',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:openrelay.metered.ca:443?transport=tcp',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:turn.anyfirewall.com:443?transport=tcp',
          username: 'webrtc',
          credential: 'webrtc'
        },
        {
          urls: 'turn:relay1.expressturn.com:3478',
          username: 'efTAJF7M2TAqVIBR3T',
          credential: 'uxXXDrkXYdkVBdkl'
        }
      ],
      iceCandidatePoolSize: 10,
      iceTransportPolicy: 'all',
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require',
      sdpSemantics: 'unified-plan'
    };

    // Mobile detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    const isNonSafariIOS = isIOS && !navigator.userAgent.includes('Safari');

    function logIce(msg) {
      console.log(`[ICE] ${msg}`);
      if (iceDebug) {
        const time = new Date().toLocaleTimeString();
        iceStatus.innerHTML += `[${time}] ${msg}<br>`;
        iceStatus.scrollTop = iceStatus.scrollHeight;
      }
    }

    function showError(msg) {
      errorMessage.textContent = msg;
      errorMessage.style.display = 'block';
      setTimeout(() => {
        errorMessage.style.display = 'none';
      }, 20000);
      logIce(`UI Error: ${msg}`);
    }

    function showLoading(show) {
      loading.style.display = show ? 'block' : 'none';
      joinBtn.disabled = show;
      joinBtn.textContent = show ? 'Connecting...' : 'Connect';
    }

    function updateStatus(status, text) {
      statusDot.className = 'status-dot ' + status;
      statusText.textContent = text;
      logIce(`Status: ${text}`);
    }

    function showVideoContainer() {
      videoContainer.classList.add('active');
      controls.style.display = 'flex';
    }

    function hideVideoContainer() {
      videoContainer.classList.remove('active');
      controls.style.display = 'none';
      playPrompt.classList.remove('visible');
    }

    function setupVideoElement() {
      remoteVideo.muted = true;
      remoteVideo.playsInline = true;
      remoteVideo.autoplay = false;
      remoteVideo.setAttribute('playsinline', 'true');
      remoteVideo.setAttribute('webkit-playsinline', 'true');
      remoteVideo.setAttribute('muted', 'true');
      remoteVideo.defaultMuted = true;
      remoteVideo.volume = 0;

      if (isMobile) {
        remoteVideo.controls = true;
        logIce('Mobile: Video controls enabled for user interaction');
      }

      remoteVideo.addEventListener('loadstart', () => {
        logIce('Video: Load started');
      });

      remoteVideo.addEventListener('loadeddata', () => {
        logIce('Video: Data loaded');
      });

      remoteVideo.addEventListener('loadedmetadata', () => {
        logIce(`Video: Metadata loaded - ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`);
        attemptVideoPlay('metadata loaded', 200);
      });

      remoteVideo.addEventListener('canplay', () => {
        logIce('Video: Can play');
        attemptVideoPlay('canplay event', 100);
      });

      remoteVideo.addEventListener('playing', () => {
        logIce('Video: Playing started');
        updateStatus('connected', 'Video playing');
        playPrompt.classList.remove('visible');
        playAttemptCount = 0;
        if (isMobile && !isIOS) {
          setTimeout(() => remoteVideo.controls = false, 3000);
        }
      });

      remoteVideo.addEventListener('pause', () => {
        logIce('Video: Paused');
        if (remoteVideo.srcObject && isMobile) {
          playPrompt.classList.add('visible');
        }
      });

      remoteVideo.addEventListener('waiting', () => {
        logIce('Video: Waiting for data');
        if (isMobile) {
          playPrompt.classList.add('visible');
        }
      });

      remoteVideo.addEventListener('error', (e) => {
        const error = e.target.error;
        logIce('Video error: ' + (error ? `${error.code} - ${error.message}` : 'Unknown error'));
        showError('Video playback error. Tap the video to retry or reconnect.');
        if (isMobile) {
          playPrompt.classList.add('visible');
        }
      });

      remoteVideo.addEventListener('stalled', () => {
        logIce('Video: Stalled, attempting to recover');
        if (isMobile) {
          playPrompt.classList.add('visible');
        }
      });

      remoteVideo.addEventListener('click', () => {
        attemptVideoPlay('user click', 0);
      });

      remoteVideo.addEventListener('touchstart', (e) => {
        e.preventDefault();
        attemptVideoPlay('user touch', 0);
      });
    }

    function attemptVideoPlay(reason, delay = 0) {
      if (!remoteVideo.srcObject) {
        logIce(`Play attempt skipped - no source (${reason})`);
        return;
      }

      if (playAttemptCount >= maxPlayAttempts) {
        logIce(`Max play attempts (${maxPlayAttempts}) reached for ${reason}`);
        showError('Unable to start video. Please reconnect or switch to a supported browser.');
        return;
      }

      setTimeout(() => {
        logIce(`Attempting video play (${playAttemptCount + 1}/${maxPlayAttempts}): ${reason}`);
        const playPromise = remoteVideo.play();

        if (playPromise !== undefined) {
          playPromise.then(() => {
            logIce(`Video play successful: ${reason}`);
            playPrompt.classList.remove('visible');
            isUserInteracted = true;
            playAttemptCount = 0;
          }).catch(e => {
            logIce(`Video play failed (${reason}): ${e.name} - ${e.message}`);
            playAttemptCount++;
            if (e.name === 'NotAllowedError') {
              showError('Tap the video to start playback (browser security requirement)');
              if (isMobile) {
                playPrompt.classList.add('visible');
              }
              if (playAttemptCount < maxPlayAttempts) {
                attemptVideoPlay(`retry after ${reason}`, 1000 * Math.min(playAttemptCount, 3));
              }
            } else if (e.name === 'AbortError') {
              logIce('Play aborted, likely due to new play request');
            } else {
              showError(`Video playback issue (${e.name}): Tap the video or reconnect.`);
              if (isMobile) {
                playPrompt.classList.add('visible');
              }
            }
          });
        }
      }, delay);
    }

    async function fetchOfferWithRetry(code, retries = 3, delay = 1000) {
      for (let i = 0; i < retries; i++) {
        try {
          const offerSnap = await get(ref(db, `signaling/${code}/offer`));
          if (!offerSnap.exists()) {
            throw new Error("Session not found. Please check the code or ensure the agent is active.");
          }
          return offerSnap.val();
        } catch (error) {
          logIce(`Offer fetch attempt ${i + 1}/${retries} failed: ${error.message}`);
          if (i < retries - 1) {
            await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
          } else {
            throw error;
          }
        }
      }
    }

    async function joinSession() {
      const code = sessionInput.value.trim().toUpperCase();
      if (!code || code.length !== 6) {
        showError("Please enter a valid 6-digit session code");
        return;
      }

      if (isNonSafariIOS) {
        showError("iOS: Please open this page in Safari for video support.");
        return;
      }

      showLoading(true);
      errorMessage.style.display = 'none';
      logIce(`Starting connection to session: ${code} (Mobile: ${isMobile}, iOS: ${isIOS}, Browser: ${navigator.userAgent.substring(0, 50)}...)`);

      try {
        currentPC = new RTCPeerConnection(pcConfig);
        currentSessionCode = code;
        reconnectAttempts = 0;
        playAttemptCount = 0;

        currentPC.oniceconnectionstatechange = () => {
          const state = currentPC.iceConnectionState;
          logIce(`ICE connection state: ${state}`);
          switch (state) {
            case 'checking':
              updateStatus('connecting', 'Checking connectivity...');
              break;
            case 'connected':
            case 'completed':
              updateStatus('connected', 'Connected via ICE');
              showLoading(false);
              reconnectAttempts = 0;
              logIce(`Connection summary: ICE=${state}, Peer=${currentPC.connectionState}`);
              break;
            case 'disconnected':
              updateStatus('connecting', 'Reconnecting...');
              if (reconnectAttempts < maxReconnectAttempts) {
                setTimeout(() => {
                  if (currentPC && currentPC.iceConnectionState === 'disconnected') {
                    logIce('Attempting ICE restart...');
                    currentPC.restartIce();
                    reconnectAttempts++;
                  }
                }, 2000);
              }
              break;
            case 'failed':
              updateStatus('error', 'Connection failed');
              if (reconnectAttempts < maxReconnectAttempts) {
                showError(`Connection failed. Retrying... (${reconnectAttempts + 1}/${maxReconnectAttempts})`);
                setTimeout(() => attemptReconnect(), 3000);
              } else {
                showError('Connection failed after multiple attempts. Check network or agent status.');
                showLoading(false);
              }
              break;
            case 'closed':
              updateStatus('connecting', 'Connection closed');
              break;
          }
        };

        currentPC.onicegatheringstatechange = () => {
          logIce(`ICE gathering state: ${currentPC.iceGatheringState}`);
        };

        currentPC.onicecandidate = async (event) => {
          if (event.candidate) {
            const candidateType = event.candidate.candidate.includes('typ host') ? 'host' :
                                 event.candidate.candidate.includes('typ srflx') ? 'srflx' :
                                 event.candidate.candidate.includes('typ relay') ? 'relay' : 'unknown';
            logIce(`New ICE candidate: ${candidateType} (${event.candidate.protocol})`);
            const viewerCandidatesRef = ref(db, `signaling/${code}/viewerCandidates`);
            await push(viewerCandidatesRef, event.candidate.toJSON());
          } else {
            logIce('ICE candidate gathering finished');
          }
        };

        currentPC.onconnectionstatechange = () => {
          const state = currentPC.connectionState;
          logIce(`Peer connection state: ${state}`);
        };

        currentPC.ontrack = (event) => {
          logIce('=== TRACK EVENT RECEIVED ===');
          logIce(`Event streams: ${event.streams.length}`);
          logIce(`Event track: ${event.track.kind} - ${event.track.readyState}`);

          const stream = event.streams[0];

          if (stream) {
            const videoTracks = stream.getVideoTracks();
            const audioTracks = stream.getAudioTracks();

            logIce(`Stream ID: ${stream.id}`);
            logIce(`Video tracks: ${videoTracks.length}`);
            logIce(`Audio tracks: ${audioTracks.length}`);

            if (videoTracks.length > 0) {
              const videoTrack = videoTracks[0];
              logIce(`Video track: ${videoTrack.label} - ${videoTrack.readyState} - Enabled: ${videoTrack.enabled}`);
            } else {
              logIce('ERROR: No video tracks received');
              showError('No video stream from agent. Ensure agent is sharing screen.');
              return;
            }

            remoteVideo.srcObject = stream;
            showVideoContainer();
            updateStatus('connected', 'Stream received');

            setTimeout(() => {
              logIce(`Video element: ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`);
              logIce(`Video paused: ${remoteVideo.paused}`);
              logIce(`Video muted: ${remoteVideo.muted}`);
              logIce(`Video readyState: ${remoteVideo.readyState}`);
              attemptVideoPlay('track received', 500);
            }, 500);

            showLoading(false);
          } else {
            logIce('ERROR: No stream received in track event');
            showError('Failed to receive stream from agent. Please reconnect.');
          }
        };

        const offer = await fetchOfferWithRetry(code);
        await currentPC.setRemoteDescription(new RTCSessionDescription(offer));

        const answerConstraints = {
          offerToReceiveVideo: true,
          offerToReceiveAudio: false
        };

        const answer = await currentPC.createAnswer(answerConstraints);
        await currentPC.setLocalDescription(answer);
        await set(ref(db, `signaling/${code}/answer`), {
          sdp: answer.sdp,
          type: answer.type
        });

        onChildAdded(ref(db, `signaling/${code}/hostCandidates`), async (snap) => {
          if (currentPC && snap.val()) {
            try {
              const candidate = snap.val();
              const candidateType = candidate.candidate.includes('typ host') ? 'host' :
                                   candidate.candidate.includes('typ srflx') ? 'srflx' :
                                   candidate.candidate.includes('typ relay') ? 'relay' : 'unknown';
              logIce(`Received ICE candidate: ${candidateType}`);
              await currentPC.addIceCandidate(new RTCIceCandidate(candidate));
              logIce('ICE candidate added successfully');
            } catch (e) {
              logIce(`Error adding ICE candidate: ${e.message}`);
              showError(`ICE candidate error: ${e.message}. Check network or agent.`);
            }
          }
        });

        setTimeout(() => {
          if (currentPC && currentPC.iceConnectionState !== 'connected' && currentPC.iceConnectionState !== 'completed') {
            logIce('Connection timeout reached');
            showError('Connection timeout. Check network or ensure agent is active.');
            showLoading(false);
          }
        }, 30000);

      } catch (error) {
        logIce(`Connection error: ${error.message}`);
        let errorMsg = error.message || 'Connection failed. Please try again.';
        if (error.message.includes('permission denied')) {
          errorMsg = 'Firebase access denied. Check session code or contact support.';
        } else if (error.message.includes('Session not found')) {
          errorMsg += ' Ensure the agent is running on desktop.';
        }
        showError(errorMsg);
        showLoading(false);
      }
    }

    async function attemptReconnect() {
      if (reconnectAttempts >= maxReconnectAttempts) return;

      reconnectAttempts++;
      logIce(`Reconnect attempt ${reconnectAttempts}/${maxReconnectAttempts}`);

      if (currentPC) {
        currentPC.close();
        currentPC = null;
      }

      await new Promise(resolve => setTimeout(resolve, 1000 * reconnectAttempts));
      await joinSession();
    }

    function disconnect() {
      if (currentPC) {
        currentPC.close();
        currentPC = null;
      }
      if (currentSessionCode) {
        off(ref(db, `signaling/${currentSessionCode}/hostCandidates`));
        currentSessionCode = null;
      }
      remoteVideo.srcObject = null;
      hideVideoContainer();
      showLoading(false);
      sessionInput.value = '';
      updateStatus('connecting', 'Disconnected');
      reconnectAttempts = 0;
      playAttemptCount = 0;
      isUserInteracted = false;
    }

    function toggleIceDebug() {
      iceDebug = !iceDebug;
      iceStatus.style.display = iceDebug ? 'block' : 'none';
      toggleIceBtn.innerHTML = iceDebug ? '<i class="fas fa-eye-slash"></i> Hide ICE' : '<i class="fas fa-code"></i> Show ICE';
      if (iceDebug) {
        iceStatus.innerHTML = '=== ICE Debug Started ===<br>';
      }
    }

    function toggleFullscreen() {
      const element = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
      if (!element) {
        if (remoteVideo.requestFullscreen) {
          remoteVideo.requestFullscreen();
        } else if (remoteVideo.webkitRequestFullscreen) {
          remoteVideo.webkitRequestFullscreen();
        } else if (remoteVideo.msRequestFullscreen) {
          remoteVideo.msRequestFullscreen();
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
    }

    sessionInput.addEventListener('input', function() {
      this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
    });

    sessionInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        joinSession();
      }
    });

    joinBtn.onclick = joinSession;
    disconnectBtn.onclick = disconnect;
    toggleIceBtn.onclick = toggleIceDebug;
    fullscreenBtn.onclick = toggleFullscreen;

    setupVideoElement();

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && currentPC && remoteVideo.srcObject) {
        logIce('Page became visible, ensuring video plays');
        attemptVideoPlay('visibility change', 500);
      }
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (remoteVideo.srcObject) {
          logIce('Orientation changed, attempting to resume');
          attemptVideoPlay('orientation change', 500);
        }
      }, 500);
    });

    window.addEventListener('beforeunload', disconnect);

    let userInteracted = false;
    function handleUserInteraction() {
      if (!userInteracted) {
        userInteracted = true;
        isUserInteracted = true;
        logIce('User interaction detected');
        if (remoteVideo.srcObject && remoteVideo.paused) {
          attemptVideoPlay('user interaction', 0);
        }
      }
    }

    document.addEventListener('touchstart', handleUserInteraction);
    document.addEventListener('click', handleUserInteraction);

    if (isIOS) {
      logIce('iOS device detected, applying iOS-specific workarounds');
      remoteVideo.controls = true;
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && remoteVideo.srcObject) {
          logIce('iOS: App became visible, checking video state');
          setTimeout(() => {
            if (remoteVideo.paused) {
              logIce('iOS: Video paused, attempting to resume');
              attemptVideoPlay('iOS visibility', 500);
            }
          }, 500);
        }
      });
      window.addEventListener('pageshow', () => {
        if (remoteVideo.srcObject && remoteVideo.paused) {
          logIce('iOS: Page shown, attempting video play');
          attemptVideoPlay('iOS pageshow', 500);
        }
      });
    }

    logIce(`Viewer initialized (Mobile: ${isMobile}, iOS: ${isIOS}, Browser: ${navigator.userAgent.substring(0, 50)}...)`);

    if (isMobile) {
      deviceInfo.innerHTML = `
        Mobile Device Detected<br>
        ${isIOS ? 'iOS: Use Safari for video support' : 'Android: Use Chrome for best experience'}<br>
        Audio: Muted | Playsinline: Enabled
      `;
    }
  </script>

  <script type="text/javascript">
  var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
  (function(){
  var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
  s1.async=true;
  s1.src='https://embed.tawk.to/689782258b3b22192a593919/1j27t8oof';
  s1.charset='UTF-8';
  s1.setAttribute('crossorigin','*');
  s0.parentNode.insertBefore(s1,s0);
  })();
  </script>
  </body>
</html>
